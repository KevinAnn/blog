# mysql性能调优

## 一、索引

### 1.索引到底是什么？

索引是排好序的数据结构。

### 2、为什么MySQL的底层采用的是B+tree进行排序的呢？

首先一般的二叉树不满足条件，可能会导致一个枝的长度越来越大，这样查询的速度和遍历一个链表没有区别。

Hash的查询复杂度是O（1），但是在对于1<n<9000，这中查询来说是不行的。

B_Tree树的特点是，每一个节点都放满了数据，导致每一个叶子节点的房的数据不是很多。

![image-20200609211203644](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211203.png)



B+Tree(B-Tree变种)

​     •非叶子节点不存储data，只存储key，可以增大度

​      •叶子节点不存储指针

​       •顺序访问指针，提高区间访问的性能

![image-20200609211155909](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211156.png)

### •B+Tree索引的性能分析

- 一般使用磁盘I/O次数评价索引结构的优劣
- 预读：磁盘一般会顺序向后读取一定长度的数据(页的整数倍)放入内存
- 局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用
- B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次I/O
- B+Tree的度d一般会超过100，因此h非常小(一般为3到5之间)

### 3、INNDB和MyISAM的索引实现

主键索引

![image-20200609211349137](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211349.png)

非主键索引

![image-20200609211354622](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211354.png)

INNDEB的实现

- InnoDB索引实现(聚集)
- 数据文件本身就是索引文件
- 表数据文件本身就是按B+Tree组织的一个索引结构文件
- 聚集索引-叶节点包含了完整的数据记录
- 为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？
- 为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)

![image-20200609211525495](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211525.png)

![image-20200609211529512](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211529.png)

对比：MYSEM的租后一层，放的是其内存地址。

​				INNDEB的最后一层放的是主键id和数据，SecondaryKey里面放的是 主键Id

### 4、联合索引

![image-20200609211814055](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200609211814.png)

记住  最佳左前缀法则就行了。

面试常温的题？

![image-20200630093658613](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200630093658.png)

## 二、如何进行优化sql?

进行explain。

1.select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。

**simple**  **primary** **subquery  ****derived**   **union**   

**3. table****列**

这一列表示 explain 的一行正在访问哪个表。

**4.type****列**

这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。

依次从最优到最差分别为：system > const > eq_ref > ref > range > index > ALL

system  const：   mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以**表最多有一个匹配行**，读取1次，速度比较快。**system****是const**的特例，表里只有一条元组匹配时为**system**

**eq_ref**：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条

**ref**：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。

**range**：范围扫描通常出现在 **in(), between ,> ,<, >=** 等操作中。使用一个索引来检索给定范围的行。

**index**：扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）

**ALL**：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了

#### **Extra**列

**Using index**：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了**覆盖索引**(**索引包含了所有查询的字段**)。对于innodb来说，如果是辅助索引性能会有不少提高

**Using where**：查询的列未被索引覆盖，where筛选条件非索引的前导列

**Using where Using index**：查询的列被索引覆盖，并且where筛选条件是索引列之一，但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据







> 索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。
>
> 尽可能不要让索引长度多大，不然可能会导致索引失效。

key_len计算规则如下：

l 字符串

n char(n)：n字节长度

n varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2

l 数值类型

n tinyint：1字节

n smallint：2字节

n int：4字节

n bigint：8字节　　

l 时间类型　

n date：3字节

n timestamp：4字节

n datetime：8字节

l 如果字段允许为 NULL，需要1字节记录是否为 NULL

## 二、MySQL事务

InnoDB里面有一个autocomit的参数（分成两个界别，session级别和global）

mysql事务的自动提交都是默认开启的.

### 1.什么是数据库的事务

事务是数据库管理系统执行过程中的一个逻辑单位，由

### 2.事务并发会带来一些问题

​		脏读：读取到其他事务未提交的数据的情况，我们称之为脏读。

​		不可重复读：读取到其它事务没有更新数据没有提交的数据。

​		幻读：一个事务前后两次读取数据数据不一致，是由于其他事务插入数据造成的

​	幻读和不可重复读的区别：

​		 不可重复读是修改或者删除，幻读是插入。

都是读引起的事务隔离级别。。

MySQL的事务隔离级别

![image-20200617143831657](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200617143831.png)

### 3.读一致性 两大实现方案

#### 1.LBCC 

  为了保证两次读到的数据是一样的，我们再读取数据的时候，锁住我们的数据，不允许其他的事务进行修改，这种方案我们称之为基于锁的并发控制Lock based Concurrency Control

#### 2.mvcc

那么我们可以在修改数据的时候给它建立一个备份或者叫快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制Multi Version Concurrency Control（MVCC）。

MVCC 的核心思想是： 我可以查到在我这个事务开始之前已经存在的数据，即使它在后面被修改或者删除了。在我这个事务之后新增的数据，我是查不到的。

InnoDB为每行记录都实现了两个隐藏字段

DB_TRX_ID 可以理解为创建版本号，每次进行更新或者插入的时候，事务编号自动递增。

DB_ROLL_PTR 回滚指针，我们可以理解为删除版本号，数据被删除或者 修改的时候记录当前事务ID，方便进行回滚。

### 3.MySQL InnoDB锁的基本类型

基本类型的锁是行锁，意向锁是表级别的锁

- 基本锁

  - ​	共享锁
  - ​    排它锁

- 意向锁

  - 意向锁是由数据库本身去维护的

  ​          也就是说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个意向共享锁。当我们      给一行数据加上排他锁之前，数据库会自动在这张表上面加一个意向排他锁。

  - ​	意向共享锁
  - ​    意向排它锁

  为什么要有意向锁呢？

  ​       意向锁是一个表级别的锁。假如事务B需要申请一个表的写锁，那么必须保证表里面不能拥有其它的共享锁或者独占锁的出现，不然就会引发冲突。那么怎么去判断这个冲突了？

  - step1：判断有没有其它事务锁住这个表

  - step2：判断表中的每一行是否已经被锁住

    如果采用的是第二种方法的，需要去遍历整张表。所以才有了意向锁。

    意向锁的动作是由数据库来完成的。不需要任伟去进行判断的。

#### 3.1锁的粒度

表级别锁和行 级别锁。

#### 3.2共享锁

第一个行级别的锁就是我们在官网看到的Shared Locks （共享锁），我们获取了一行数据的读锁以后，可以用来读取数据，所以它也叫做读锁，注意不要在加上了读锁以后去写数据，不然的话可能会出现死锁的情况。

select …… lock in share mode;

如何进行释放了  只要事务结束，锁就会自动事务，包括提交事务和结束事务。

#### 3.3 排它锁

只要一个事务获取了一行数据的排它锁，其他的事务就不能再获取这一行数据的共享锁和排它锁。

排它锁的加锁方式有两种，第一种是自动加排他锁。我们在操作数据的时候，包括增删改，都会默认加上一个排它锁。还有一种是手工加锁，我们用一个FOR UPDATE 给一行数据加上一个排它锁，这个无论是在我们的代码里面还是操作数据的工具里面，都比较常用。

### 3.行锁的实现

#### 3.1 记录锁

​		第一种情况我们可以对唯一性索引使用等值进行查询，精准匹配到一条记录的时候，这个时候我们使用的就是记录锁。

#### 3.2 间隙锁

![image-20200630150757596](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200630150757.png)

​		第二种情况，当我们使用查询的记录不存在的时候，没有命中任何一个record，无论是用等值还是使用范围查询的时候，它使用的都是间隙锁。

​		数据不存在的区间，记录锁没有命中。主要是用来阻塞插入，就是事务隔级别RR，用于解决幻读。

#### 	3.3临键锁

![image-20200630151213363](https://gitee.com/anqingjieer/pengbo/raw/master/img/20200630151213.png)

### 4、mysql 中inndb和mysam的区别

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一； 

2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  

3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 

4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    

5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；



